<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InsuranceIntegrationHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">backv5</a> &gt; <a href="index.source.html" class="el_package">com.sources.app.handlers</a> &gt; <span class="el_source">InsuranceIntegrationHandler.java</span></div><h1>InsuranceIntegrationHandler.java</h1><pre class="source lang-java linenums">package com.sources.app.handlers;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.sources.app.dao.BillDAO;
import com.sources.app.dao.PrescriptionDAO;
import com.sources.app.entities.Bill;
import com.sources.app.entities.Prescription;
import com.sources.app.util.ExternalServiceClient;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;

/**
 * Manejador HTTP para la integración con el sistema de seguros. Gestiona la
 * validación de recetas y la verificación de cobertura interactuando con un
 * servicio externo de seguros.
 */
public class InsuranceIntegrationHandler implements HttpHandler {

    private final PrescriptionDAO prescriptionDAO;
    private final BillDAO billDAO;
    private final ObjectMapper objectMapper;
    private static final String ENDPOINT = &quot;/api2/insurance&quot;;
<span class="fc" id="L32">    private static final Logger LOGGER = Logger.getLogger(InsuranceIntegrationHandler.class.getName());</span>
    // Cliente para llamadas HTTP externas (inyectable para pruebas)
    private final ExternalServiceClient externalServiceClient;

    /**
     * Constructor para InsuranceIntegrationHandler.
     *
     * @param prescriptionDAO DAO para acceder a los datos de las
     * prescripciones.
     * @param billDAO DAO para acceder a los datos de las facturas.
     */
<span class="fc" id="L43">    public InsuranceIntegrationHandler(PrescriptionDAO prescriptionDAO, BillDAO billDAO) {</span>
<span class="fc" id="L44">        this.prescriptionDAO = prescriptionDAO;</span>
<span class="fc" id="L45">        this.billDAO = billDAO;</span>
<span class="fc" id="L46">        this.objectMapper = new ObjectMapper();</span>
<span class="fc" id="L47">        this.externalServiceClient = new ExternalServiceClient();</span>
<span class="fc" id="L48">    }</span>

    /**
     * Constructor adicional que permite inyectar un ExternalServiceClient (para pruebas).
     */
<span class="fc" id="L53">    public InsuranceIntegrationHandler(PrescriptionDAO prescriptionDAO, BillDAO billDAO, ExternalServiceClient externalServiceClient) {</span>
<span class="fc" id="L54">        this.prescriptionDAO = prescriptionDAO;</span>
<span class="fc" id="L55">        this.billDAO = billDAO;</span>
<span class="fc" id="L56">        this.objectMapper = new ObjectMapper();</span>
<span class="fc" id="L57">        this.externalServiceClient = externalServiceClient;</span>
<span class="fc" id="L58">    }</span>

    /**
     * Maneja las solicitudes HTTP entrantes. Dirige las solicitudes POST a los
     * endpoints /validate-prescription y /check-coverage a sus respectivos
     * métodos de manejo. Responde con 405 Method Not Allowed para otros métodos
     * y 404 Not Found para otras rutas.
     *
     * @param exchange El objeto HttpExchange que representa la solicitud y
     * respuesta.
     * @throws IOException Si ocurre un error de entrada/salida.
     */
    @Override
    public void handle(HttpExchange exchange) throws IOException {
        // Set CORS headers
<span class="fc" id="L73">        exchange.getResponseHeaders().add(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span>
<span class="fc" id="L74">        exchange.getResponseHeaders().add(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, OPTIONS&quot;);</span>
<span class="fc" id="L75">        exchange.getResponseHeaders().add(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization&quot;);</span>

        // Handle CORS preflight
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (&quot;OPTIONS&quot;.equalsIgnoreCase(exchange.getRequestMethod())) {</span>
<span class="fc" id="L79">            exchange.sendResponseHeaders(204, -1);</span>
<span class="fc" id="L80">            return;</span>
        }

<span class="fc" id="L83">        String path = exchange.getRequestURI().getPath();</span>
<span class="fc" id="L84">        String method = exchange.getRequestMethod();</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (path.equals(ENDPOINT + &quot;/validate-prescription&quot;)) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (method.equals(&quot;POST&quot;)) {</span>
<span class="fc" id="L88">                handleValidatePrescription(exchange);</span>
            } else {
<span class="fc" id="L90">                sendMethodNotAllowed(exchange);</span>
            }
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (path.equals(ENDPOINT + &quot;/check-coverage&quot;)) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (method.equals(&quot;POST&quot;)) {</span>
<span class="fc" id="L94">                handleCheckCoverage(exchange);</span>
            } else {
<span class="fc" id="L96">                sendMethodNotAllowed(exchange);</span>
            }
        } else {
<span class="fc" id="L99">            exchange.sendResponseHeaders(404, -1);</span>
        }
<span class="fc" id="L101">    }</span>

    /**
     * Maneja la solicitud POST para validar una prescripción con el seguro.
     * Extrae el ID de la prescripción y el código de aprobación del cuerpo de
     * la solicitud. Busca la prescripción, verifica si ya ha sido facturada,
     * calcula el total, llama al servicio externo del seguro para validar y, si
     * es exitoso, crea una factura en la base de datos.
     *
     * @param exchange El objeto HttpExchange.
     * @throws IOException Si ocurre un error de entrada/salida o durante la
     * comunicación con el seguro.
     */
    private void handleValidatePrescription(HttpExchange exchange) throws IOException {
<span class="fc" id="L115">        String requestBody = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L116">        Map&lt;String, Object&gt; data = objectMapper.readValue(requestBody, Map.class);</span>

        // Validar datos requeridos
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">        if (!data.containsKey(&quot;prescriptionId&quot;) || !data.containsKey(&quot;approvalCode&quot;)) {</span>
<span class="fc" id="L120">            sendBadRequest(exchange, &quot;Campos requeridos: prescriptionId, approvalCode&quot;);</span>
<span class="fc" id="L121">            return;</span>
        }

<span class="fc" id="L124">        Long prescriptionId = Long.valueOf(data.get(&quot;prescriptionId&quot;).toString());</span>
<span class="fc" id="L125">        String approvalCode = (String) data.get(&quot;approvalCode&quot;);</span>

        // Buscar la receta
<span class="fc" id="L128">        Prescription prescription = prescriptionDAO.getById(prescriptionId);</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (prescription == null) {</span>
<span class="fc" id="L131">            sendNotFound(exchange, &quot;Receta no encontrada&quot;);</span>
<span class="fc" id="L132">            return;</span>
        }

        // Si ya existe una factura para esta receta, retornar error
<span class="fc" id="L136">        Bill existingBill = billDAO.getByPrescriptionId(prescriptionId);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (existingBill != null) {</span>
<span class="fc" id="L138">            sendResponse(exchange, 400, objectMapper.writeValueAsString(Map.of(</span>
<span class="fc" id="L139">                    &quot;success&quot;, false,</span>
                    &quot;message&quot;, &quot;Esta receta ya fue procesada y facturada&quot;
            )));
<span class="fc" id="L142">            return;</span>
        }

        // Calcular el total de la receta
<span class="fc" id="L146">        double totalAmount = prescription.calculateTotal();</span>

        // Datos para enviar al seguro
<span class="fc" id="L149">        Map&lt;String, Object&gt; insuranceData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L150">        insuranceData.put(&quot;approvalCode&quot;, approvalCode);</span>
<span class="fc" id="L151">        insuranceData.put(&quot;prescriptionId&quot;, prescriptionId);</span>
<span class="fc" id="L152">        insuranceData.put(&quot;totalAmount&quot;, totalAmount);</span>

        try {
            // Llamar al servicio del seguro
<span class="fc" id="L156">            String serviceType = &quot;INSURANCE&quot;;</span>
<span class="fc" id="L157">            String endpoint = &quot;/validate-prescription&quot;;</span>
<span class="fc" id="L158">            String jsonResponse = externalServiceClient.post(serviceType, endpoint, insuranceData);</span>

            // Parsear la respuesta
<span class="fc" id="L161">            Map&lt;String, Object&gt; insuranceResponse = objectMapper.readValue(jsonResponse, Map.class);</span>

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (Boolean.TRUE.equals(insuranceResponse.get(&quot;success&quot;))) {</span>
                // Crear la factura
<span class="fc" id="L165">                Bill bill = new Bill();</span>
<span class="fc" id="L166">                bill.setPrescription(prescription);</span>
<span class="fc" id="L167">                bill.setTotalAmount(totalAmount);</span>
<span class="fc" id="L168">                bill.setCoveredAmount((Double) insuranceResponse.get(&quot;coveredAmount&quot;));</span>
<span class="fc" id="L169">                bill.setPatientAmount((Double) insuranceResponse.get(&quot;patientAmount&quot;));</span>
<span class="fc" id="L170">                bill.setInsuranceApprovalCode((String) insuranceResponse.get(&quot;approvalCode&quot;));</span>
<span class="fc" id="L171">                bill.setCreatedAt(new Date());</span>
<span class="fc" id="L172">                bill.setStatus(&quot;PENDING&quot;);</span>

                // Asignando los valores requeridos por el método create de billDAO
<span class="fc" id="L175">                Double taxes = totalAmount * 0.07; // Ejemplo: 7% de impuestos</span>
<span class="fc" id="L176">                Double subtotal = totalAmount - taxes;</span>
<span class="fc" id="L177">                Double copay = bill.getPatientAmount();</span>
<span class="fc" id="L178">                String totalStr = String.valueOf(totalAmount);</span>

<span class="fc" id="L180">                Bill savedBill = billDAO.create(prescription, taxes, subtotal, copay, totalStr);</span>

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                if (savedBill != null) {</span>
<span class="fc" id="L183">                    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;(insuranceResponse);</span>
<span class="fc" id="L184">                    response.put(&quot;billId&quot;, savedBill.getId());</span>
<span class="fc" id="L185">                    sendResponse(exchange, 200, objectMapper.writeValueAsString(response));</span>
<span class="fc" id="L186">                } else {</span>
<span class="nc" id="L187">                    sendResponse(exchange, 500, objectMapper.writeValueAsString(Map.of(</span>
<span class="nc" id="L188">                            &quot;success&quot;, false,</span>
                            &quot;message&quot;, &quot;Error al guardar la factura&quot;
                    )));
                }
<span class="fc" id="L192">            } else {</span>
                // Enviar la respuesta de error del seguro
<span class="nc" id="L194">                sendResponse(exchange, 400, jsonResponse);</span>
            }
<span class="fc" id="L196">        } catch (Exception e) {</span>
<span class="fc" id="L197">            LOGGER.log(Level.SEVERE, &quot;Error en validate-prescription&quot;, e);</span>
<span class="fc" id="L198">            sendResponse(exchange, 500, objectMapper.writeValueAsString(Map.of(</span>
<span class="fc" id="L199">                    &quot;success&quot;, false,</span>
<span class="fc" id="L200">                    &quot;message&quot;, &quot;Error al comunicarse con el seguro: &quot; + e.getMessage()</span>
            )));
<span class="fc" id="L202">        }</span>
<span class="fc" id="L203">    }</span>

    /**
     * Maneja la solicitud POST para verificar la cobertura de una prescripción
     * con el seguro. Extrae el ID de la prescripción del cuerpo de la solicitud
     * y llama al servicio externo del seguro para obtener la información de
     * cobertura.
     *
     * @param exchange El objeto HttpExchange.
     * @throws IOException Si ocurre un error de entrada/salida o durante la
     * comunicación con el seguro.
     */
    private void handleCheckCoverage(HttpExchange exchange) throws IOException {
<span class="fc" id="L216">        String requestBody = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L217">        Map&lt;String, Object&gt; data = objectMapper.readValue(requestBody, Map.class);</span>

        // Validar datos requeridos
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (!data.containsKey(&quot;prescriptionId&quot;)) {</span>
<span class="fc" id="L221">            sendBadRequest(exchange, &quot;Campo requerido: prescriptionId&quot;);</span>
<span class="fc" id="L222">            return;</span>
        }

<span class="fc" id="L225">        Long prescriptionId = Long.valueOf(data.get(&quot;prescriptionId&quot;).toString());</span>

        try {
            // Llamar al servicio del seguro
<span class="fc" id="L229">            String serviceType = &quot;INSURANCE&quot;;</span>
<span class="fc" id="L230">            String endpoint = &quot;/check-coverage/&quot; + prescriptionId;</span>
<span class="fc" id="L231">            String jsonResponse = externalServiceClient.get(serviceType, endpoint);</span>

            // Enviar la respuesta del seguro
<span class="fc" id="L234">            sendResponse(exchange, 200, jsonResponse);</span>
<span class="fc" id="L235">        } catch (Exception e) {</span>
<span class="fc" id="L236">            LOGGER.log(Level.SEVERE, &quot;Error en check-coverage&quot;, e);</span>
<span class="fc" id="L237">            sendResponse(exchange, 500, objectMapper.writeValueAsString(Map.of(</span>
<span class="fc" id="L238">                    &quot;success&quot;, false,</span>
<span class="fc" id="L239">                    &quot;message&quot;, &quot;Error al comunicarse con el seguro: &quot; + e.getMessage()</span>
            )));
<span class="fc" id="L241">        }</span>
<span class="fc" id="L242">    }</span>

    /**
     * Envía una respuesta HTTP 405 Method Not Allowed.
     *
     * @param exchange El objeto HttpExchange.
     * @throws IOException Si ocurre un error de entrada/salida.
     */
    private void sendMethodNotAllowed(HttpExchange exchange) throws IOException {
<span class="fc" id="L251">        exchange.sendResponseHeaders(405, -1);</span>
<span class="fc" id="L252">    }</span>

    /**
     * Envía una respuesta HTTP 400 Bad Request con un mensaje de error.
     *
     * @param exchange El objeto HttpExchange.
     * @param message El mensaje de error a incluir en la respuesta JSON.
     * @throws IOException Si ocurre un error de entrada/salida.
     */
    private void sendBadRequest(HttpExchange exchange, String message) throws IOException {
<span class="fc" id="L262">        sendResponse(exchange, 400, objectMapper.writeValueAsString(Map.of(</span>
<span class="fc" id="L263">                &quot;success&quot;, false,</span>
                &quot;message&quot;, message
        )));
<span class="fc" id="L266">    }</span>

    /**
     * Envía una respuesta HTTP 404 Not Found con un mensaje de error.
     *
     * @param exchange El objeto HttpExchange.
     * @param message El mensaje de error a incluir en la respuesta JSON.
     * @throws IOException Si ocurre un error de entrada/salida.
     */
    private void sendNotFound(HttpExchange exchange, String message) throws IOException {
<span class="fc" id="L276">        sendResponse(exchange, 404, objectMapper.writeValueAsString(Map.of(</span>
<span class="fc" id="L277">                &quot;success&quot;, false,</span>
                &quot;message&quot;, message
        )));
<span class="fc" id="L280">    }</span>

    /**
     * Envía una respuesta HTTP con el código de estado y cuerpo de respuesta
     * especificados. Establece la cabecera Content-Type a application/json.
     *
     * @param exchange El objeto HttpExchange.
     * @param statusCode El código de estado HTTP para la respuesta.
     * @param response El cuerpo de la respuesta como una cadena String (se
     * asume JSON).
     * @throws IOException Si ocurre un error de entrada/salida.
     */
    private void sendResponse(HttpExchange exchange, int statusCode, String response) throws IOException {
<span class="fc" id="L293">        exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json&quot;);</span>
<span class="fc" id="L294">        byte[] responseBytes = response.getBytes(StandardCharsets.UTF_8);</span>
<span class="fc" id="L295">        exchange.sendResponseHeaders(statusCode, responseBytes.length);</span>

<span class="fc" id="L297">        try (OutputStream os = exchange.getResponseBody()) {</span>
<span class="fc" id="L298">            os.write(responseBytes);</span>
        }
<span class="fc" id="L300">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>